"""Generate static DuckDB function namespace classes."""

from __future__ import annotations

from collections import defaultdict
import keyword
from pathlib import Path
from textwrap import indent

import duckdb

HEADER = """Auto-generated DuckDB function namespaces.

This file is generated by ``scripts/generate_function_namespaces.py``.
Do not edit by hand; regenerate to pull in new function definitions.
"""

SCHEMA_PRIORITY = {"main": 0, "duckdb": 1, "pg_catalog": 2}
RETURN_CATEGORY_DOCS = {
    "numeric": "numeric",
    "boolean": "boolean",
    "varchar": "string",
    "blob": "binary",
    "generic": "generic",
}
CATEGORY_TO_EXPRESSION = {
    "numeric": "NumericExpression",
    "boolean": "BooleanExpression",
    "varchar": "VarcharExpression",
    "blob": "BlobExpression",
    "generic": "TypedExpression",
}
STUB_VALID_TYPE_IGNORE = {"list"}


def _categorise_return_type(return_type: str | None) -> str:
    if return_type is None:
        return "generic"
    normalized = return_type.upper()
    if any(
        normalized.startswith(prefix)
        for prefix in (
            "TINYINT",
            "SMALLINT",
            "INTEGER",
            "BIGINT",
            "HUGEINT",
            "UTINYINT",
            "USMALLINT",
            "UINTEGER",
            "UBIGINT",
            "FLOAT",
            "DOUBLE",
            "DECIMAL",
            "REAL",
            "INTERVAL",
        )
    ):
        return "numeric"
    if normalized.startswith("BOOLEAN"):
        return "boolean"
    if any(
        normalized.startswith(prefix) for prefix in ("VARCHAR", "STRING", "TEXT", "JSON", "UUID")
    ):
        return "varchar"
    if normalized.startswith("BLOB"):
        return "blob"
    return "generic"


def _definition_sort_key(
    definition: tuple[
        str,
        str,
        str | None,
        tuple[str, ...],
        tuple[str, ...],
        str | None,
        str | None,
        str | None,
        str | None,
    ]
) -> tuple[int, int]:
    schema, _name, _rtype, parameter_types, _parameter_names, _varargs, *_ = definition
    schema_priority = SCHEMA_PRIORITY.get(schema, 10)
    arity = len(parameter_types)
    return (schema_priority, arity)


def _load_definitions() -> dict[
    str,
    dict[
        str,
        dict[
            str,
            list[
                tuple[
                    str,
                    str,
                    str | None,
                    tuple[str, ...],
                    tuple[str, ...],
                    str | None,
                    str | None,
                    str | None,
                    str | None,
                ]
            ],
        ],
    ],
]:
    connection = duckdb.connect()
    try:
        rows = connection.execute(
            """
            SELECT schema_name,
                   function_name,
                   function_type,
                   return_type,
                   parameters,
                   parameter_types,
                   varargs,
                   description,
                   comment,
                   macro_definition
              FROM duckdb_functions()
             WHERE function_type IN ('scalar', 'aggregate', 'window')
            """
        ).fetchall()
    finally:
        connection.close()

    index: dict[str, dict[str, dict[str, list[tuple[str, str, str | None, tuple[str, ...], tuple[str, ...], str | None, str | None, str | None, str | None]]]]] = defaultdict(
        lambda: defaultdict(dict)
    )
    for (
        schema_name,
        function_name,
        function_type,
        return_type,
        parameters,
        parameter_types,
        varargs,
        description,
        comment,
        macro_definition,
    ) in rows:
        category = _categorise_return_type(return_type)
        type_bucket = index[function_type]
        category_bucket = type_bucket.setdefault(category, defaultdict(list))
        parameter_types_tuple = tuple(parameter_types or ())
        parameter_names_tuple = tuple(parameters or ())
        category_bucket[function_name].append(
            (
                schema_name,
                function_name,
                return_type,
                parameter_types_tuple,
                parameter_names_tuple,
                varargs,
                description,
                comment,
                macro_definition,
            )
        )

    for type_bucket in index.values():
        for category_bucket in type_bucket.values():
            for overloads in category_bucket.values():
                overloads.sort(key=_definition_sort_key)

    return index


def _format_type(type_spec: str | None) -> str:
    if type_spec is None:
        return "None"
    return f"parse_type({type_spec!r})"


def _format_parameters(parameters: tuple[str, ...]) -> str:
    if not parameters:
        return "()"
    formatted = ", ".join(_format_type(parameter) for parameter in parameters)
    if len(parameters) == 1:
        formatted += ","
    return f"({formatted})"


def _format_parameter_names(names: tuple[str, ...]) -> str:
    if not names:
        return "()"
    formatted = ", ".join(repr(name) for name in names)
    if len(names) == 1:
        formatted += ","
    return f"({formatted})"


def _format_definition(
    schema: str,
    name: str,
    return_type: str | None,
    parameters: tuple[str, ...],
    parameter_names: tuple[str, ...],
    varargs: str | None,
    description: str | None,
    comment: str | None,
    macro_definition: str | None,
) -> str:
    return "\n".join(
        [
            "            DuckDBFunctionDefinition(",
            f"                schema_name={schema!r},",
            f"                function_name={name!r},",
            "                function_type=function_type,",
            f"                return_type={_format_type(return_type)},",
            f"                parameter_types={_format_parameters(parameters)},",
            f"                parameters={_format_parameter_names(parameter_names)},",
            f"                varargs={_format_type(varargs)},",
            f"                description={description!r},",
            f"                comment={comment!r},",
            f"                macro_definition={macro_definition!r},",
            "            ),",
        ]
    )


def _render_function_block(
    function_name: str,
    overloads: list[
        tuple[
            str,
            str,
            str | None,
            tuple[str, ...],
            tuple[str, ...],
            str | None,
            str | None,
            str | None,
            str | None,
        ]
    ],
    *,
    return_category: str,
    call_class: str = "_DuckDBFunctionCall",
) -> str:
    lines = [f"    {function_name} = {call_class}(("]
    lines.extend(
        _format_definition(
            schema,
            name,
            return_type,
            parameter_types,
            parameter_names,
            varargs,
            description,
            comment,
            macro_definition,
        )
        for (
            schema,
            name,
            return_type,
            parameter_types,
            parameter_names,
            varargs,
            description,
            comment,
            macro_definition,
        ) in overloads
    )
    lines.append("        ),")
    lines.append(f"        return_category={return_category!r},")
    lines.append("    )")
    return "\n".join(lines)


def _render_symbolic_mapping(
    overloads: dict[
        str,
        list[
            tuple[
                str,
                str,
                str | None,
                tuple[str, ...],
                tuple[str, ...],
                str | None,
                str | None,
                str | None,
                str | None,
            ]
        ],
    ],
    *,
    return_category: str,
) -> str:
    if not overloads:
        return "    _SYMBOLIC_FUNCTIONS: ClassVar[dict[str, _DuckDBFunctionCall]] = {}"
    items = []
    for function_name in sorted(overloads):
        block_lines = ["        " + repr(function_name) + ": _DuckDBFunctionCall(("]
        block_lines.extend(
            indent(
                _format_definition(
                    schema,
                    name,
                    return_type,
                    parameter_types,
                    parameter_names,
                    varargs,
                    description,
                    comment,
                    macro_definition,
                ),
                "            ",
            )
            for (
                schema,
                name,
                return_type,
                parameter_types,
                parameter_names,
                varargs,
                description,
                comment,
                macro_definition,
            ) in overloads[function_name]
        )
        block_lines.append("            ),")
        block_lines.append(f"            return_category={return_category!r},")
        block_lines.append("        ),")
        items.append("\n".join(block_lines))
    mapping = "\n".join(items)
    return "\n".join(
        [
            "    _SYMBOLIC_FUNCTIONS: ClassVar[dict[str, _DuckDBFunctionCall]] = {",
            mapping,
            "    }",
        ]
    )


def _render_namespace(
    *,
    function_type: str,
    category: str,
    identifiers: dict[
        str,
        list[
            tuple[
                str,
                str,
                str | None,
                tuple[str, ...],
                tuple[str, ...],
                str | None,
                str | None,
                str | None,
                str | None,
            ]
        ],
    ],
    symbols: dict[
        str,
        list[
            tuple[
                str,
                str,
                str | None,
                tuple[str, ...],
                tuple[str, ...],
                str | None,
                str | None,
                str | None,
                str | None,
            ]
        ],
    ],
) -> str:
    class_name = f"{function_type.title()}{category.title()}Functions"
    doc_category = RETURN_CATEGORY_DOCS.get(category, category)
    doc = f"DuckDB {function_type} functions returning {doc_category} results."
    lines: list[str] = [f"class {class_name}(_StaticFunctionNamespace):", f"    \"\"\"{doc}\"\"\""]
    lines.append("    __slots__ = ()")
    lines.append("    function_type: ClassVar[str] = " + repr(function_type))
    lines.append("    return_category: ClassVar[str] = " + repr(category))
    if identifiers:
        for function_name in sorted(identifiers):
            lines.append(
                _render_function_block(
                    function_name,
                    identifiers[function_name],
                    return_category=category,
                )
            )
            if function_type == "aggregate":
                filter_name = f"{function_name}_filter"
                lines.append(
                    _render_function_block(
                        filter_name,
                        identifiers[function_name],
                        return_category=category,
                        call_class="_DuckDBFilterFunctionCall",
                    )
                )
        registry_lines = ["    _IDENTIFIER_FUNCTIONS: ClassVar[dict[str, _DuckDBFunctionCall]] = {"]
        for function_name in sorted(identifiers):
            registry_lines.append(f"        {function_name!r}: {function_name},")
            if function_type == "aggregate":
                filter_key = f"{function_name}_filter"
                registry_lines.append(f"        {filter_key!r}: {filter_key},")
        registry_lines.append("    }")
        lines.append("\n".join(registry_lines))
    else:
        lines.append("    _IDENTIFIER_FUNCTIONS: ClassVar[dict[str, _DuckDBFunctionCall]] = {}")
    lines.append(
        _render_symbolic_mapping(
            symbols,
            return_category=category,
        )
    )
    return "\n".join(lines)


def _render_stub_namespace(
    *,
    function_type: str,
    category: str,
    identifiers: dict[
        str,
        list[
            tuple[
                str,
                str,
                str | None,
                tuple[str, ...],
                tuple[str, ...],
                str | None,
                str | None,
                str | None,
                str | None,
            ]
        ],
    ],
) -> str:
    class_name = f"{function_type.title()}{category.title()}Functions"
    expression = CATEGORY_TO_EXPRESSION[category]
    lines = [f"class {class_name}(_StaticFunctionNamespace[{expression}]):"]
    lines.append("    ...")
    if identifiers:
        for function_name in sorted(identifiers):
            annotation = f"    {function_name}: _DuckDBFunctionCall[{expression}]"
            if function_name in STUB_VALID_TYPE_IGNORE:
                annotation += "  # type: ignore[valid-type]"
            lines.append(annotation)
            if function_type == "aggregate":
                filter_annotation = f"    {function_name}_filter: _DuckDBFunctionCall[{expression}]"
                if function_name in STUB_VALID_TYPE_IGNORE:
                    filter_annotation += "  # type: ignore[valid-type]"
                lines.append(filter_annotation)
    return "\n".join(lines)


def _render_type_namespace(function_type: str, categories: dict[str, str]) -> str:
    class_name = f"{function_type.title()}FunctionNamespace"
    lines = [
        f"class {class_name}:",
        f"    \"\"\"DuckDB {function_type} function categories.\"\"\"",
        "    __slots__ = ()",
    ]
    for category_name, cls_name in categories.items():
        lines.append(
            f"    {category_name.title()}: {cls_name} = {cls_name}()  # noqa: N802"
        )
    lines.append("    def __dir__(self) -> list[str]:")
    lines.append(
        "        return sorted(name for name in self.__class__.__dict__ if not name.startswith('_'))"
    )
    return "\n".join(lines)


def _render_stub_type_namespace(function_type: str, categories: dict[str, str]) -> str:
    class_name = f"{function_type.title()}FunctionNamespace"
    lines = [f"class {class_name}:", "    ..."]
    for category_name, cls_name in categories.items():
        lines.append(f"    {category_name.title()}: {cls_name}")
    lines.append("    def __dir__(self) -> list[str]: ...")
    return "\n".join(lines)


def _render_catalog_markdown(
    catalog: dict[str, dict[str, dict[str, set[str]]]],
) -> str:
    lines = [
        "# DuckDB typed function catalog (DuckPlus 1.1)",
        "",
        "This catalog enumerates every DuckDB scalar, aggregate, and window function",
        "exposed through DuckPlus' static typed API. Entries are grouped by return",
        "category to match the generated namespaces.",
        "",
        "Aggregate helpers also expose ``_filter`` variants that render ``FILTER",
        "(WHERE ...)`` with a typed boolean predicate as the first argument.",
        "",
        "The file is auto-generated by ``scripts/generate_function_namespaces.py``;",
        "run the script after upgrading DuckDB to refresh the catalog.",
        "",
    ]

    for function_type in ("scalar", "aggregate", "window"):
        type_bucket = catalog.get(function_type, {})
        lines.append(f"## {function_type.title()} functions")
        lines.append("")
        if not type_bucket:
            lines.append("(No functions exposed in this release.)")
            lines.append("")
            continue
        for category, entries in sorted(type_bucket.items()):
            lines.append(f"### {category.title()} results")
            identifiers = sorted(entries["identifiers"])
            symbols = sorted(entries["symbols"])
            if identifiers:
                for name in identifiers:
                    lines.append(f"- ``{name}``")
            else:
                lines.append("- *(no identifier functions)*")
            if symbols:
                lines.append("")
                lines.append("Symbolic operators:")
                for symbol in symbols:
                    lines.append(f"- ``{symbol}``")
            lines.append("")
        lines.append("")

    return "\n".join(lines).rstrip() + "\n"


def main() -> None:
    index = _load_definitions()
    for function_type in ("aggregate", "scalar", "window"):
        type_bucket = index.setdefault(function_type, {})
        for category in ("blob", "boolean", "generic", "numeric", "varchar"):
            type_bucket.setdefault(category, {})
    catalog: dict[
        str,
        dict[str, dict[str, set[str]]],
    ] = defaultdict(lambda: defaultdict(lambda: {"identifiers": set(), "symbols": set()}))

    output_lines: list[str] = [
        "from __future__ import annotations",
        "",
        "from typing import ClassVar",
        "",
        "from .functions import (",
        "    DuckDBFunctionDefinition,",
        "    _DuckDBFilterFunctionCall,",
        "    _DuckDBFunctionCall,",
        "    _StaticFunctionNamespace,",
        ")",
        "from .types import parse_type",
        "",
        "",
    ]
    stub_lines: list[str] = [
        "from __future__ import annotations",
        "",
        "from typing import ClassVar, Generic, Mapping, Tuple, TypeVar, Protocol",
        "",
        "from .expression import BlobExpression, BooleanExpression, GenericExpression, NumericExpression, TypedExpression, VarcharExpression",
        "",
        "class DuckDBFunctionDefinition: ...",
        "class DuckDBFunctionSignature: ...",
        "_ExprT = TypeVar('_ExprT', bound=TypedExpression, covariant=True)",
        "",
        "class _DuckDBFunctionCall(Protocol[_ExprT]):",
        "    signatures: Tuple[DuckDBFunctionSignature, ...]",
        "    function_type: str",
        "    def __call__(self, *operands: object) -> _ExprT: ...",
        "",
        "_NamespaceExprT = TypeVar('_NamespaceExprT', bound=TypedExpression)",
        "",
        "class _StaticFunctionNamespace(Generic[_NamespaceExprT]):",
        "    function_type: ClassVar[str]",
        "    return_category: ClassVar[str]",
        "    _IDENTIFIER_FUNCTIONS: Mapping[str, _DuckDBFunctionCall[_NamespaceExprT]]",
        "    _SYMBOLIC_FUNCTIONS: Mapping[str, _DuckDBFunctionCall[_NamespaceExprT]]",
        "    def __getitem__(self, name: str) -> _DuckDBFunctionCall[_NamespaceExprT]: ...",
        "    def get(",
        "        self,",
        "        name: str,",
        "        default: _DuckDBFunctionCall[_NamespaceExprT] | None = ...,",
        "    ) -> _DuckDBFunctionCall[_NamespaceExprT] | None: ...",
        "    def __contains__(self, name: object) -> bool: ...",
        "    @property",
        "    def symbols(self) -> Mapping[str, _DuckDBFunctionCall[_NamespaceExprT]]: ...",
        "    def __dir__(self) -> list[str]: ...",
        "",
    ]

    for function_type, categories in sorted(index.items()):
        for category, functions in sorted(categories.items()):
            identifiers: dict[str, list[tuple[str, str, str | None, tuple[str, ...], str | None]]] = {}
            symbols: dict[str, list[tuple[str, str, str | None, tuple[str, ...], str | None]]] = {}
            for name, overloads in functions.items():
                catalog_entry = catalog[function_type][category]
                if name.isidentifier() and not keyword.iskeyword(name):
                    identifiers[name] = overloads
                    catalog_entry["identifiers"].add(name)
                else:
                    symbols[name] = overloads
                    catalog_entry["symbols"].add(name)
            output_lines.append(
                _render_namespace(
                    function_type=function_type,
                    category=category,
                    identifiers=identifiers,
                    symbols=symbols,
                )
            )
            output_lines.append("")
            stub_lines.append(
                _render_stub_namespace(
                    function_type=function_type,
                    category=category,
                    identifiers=identifiers,
                )
            )
            stub_lines.append("")

        categories = {
            category: f"{function_type.title()}{category.title()}Functions"
            for category in sorted(categories)
        }
        output_lines.append(_render_type_namespace(function_type, categories))
        output_lines.append("")
        stub_lines.append(_render_stub_type_namespace(function_type, categories))
        stub_lines.append("")

    stub_lines.extend(
        [
            "class DuckDBFunctionNamespace:",
            "    ...",
            "    Scalar: ScalarFunctionNamespace",
            "    Aggregate: AggregateFunctionNamespace",
            "    Window: WindowFunctionNamespace",
            "    def __dir__(self) -> list[str]: ...",
            "",
            "SCALAR_FUNCTIONS: ScalarFunctionNamespace",
            "AGGREGATE_FUNCTIONS: AggregateFunctionNamespace",
            "WINDOW_FUNCTIONS: WindowFunctionNamespace",
            "",
            "__all__ = [",
            "    'DuckDBFunctionDefinition',",
            "    'DuckDBFunctionNamespace',",
            "    'DuckDBFunctionSignature',",
            "    'SCALAR_FUNCTIONS',",
            "    'AGGREGATE_FUNCTIONS',",
            "    'WINDOW_FUNCTIONS',",
            "]",
        ]
    )

    output_path = Path(__file__).resolve().parent.parent / "duckplus" / "typed" / "_generated_function_namespaces.py"
    output = "\n".join(output_lines).strip() + "\n"
    prologue = "# pylint: skip-file\n# mypy: ignore-errors\n\n" + f'"""{HEADER}\n"""\n\n'
    output_path.write_text(prologue + output, encoding="utf-8")
    print(f"Wrote {output_path}")

    stub_path = output_path.with_suffix(".pyi")
    stub_body = "\n".join(stub_lines).strip() + "\n"
    stub_prologue = f'"""{HEADER}\n"""\n\n'
    stub_path.write_text(stub_prologue + stub_body, encoding="utf-8")
    print(f"Wrote {stub_path}")

    catalog_path = (
        Path(__file__).resolve().parent.parent
        / "docs"
        / "versions"
        / "1.1"
        / "api"
        / "typed"
        / "function_catalog.md"
    )
    catalog_path.parent.mkdir(parents=True, exist_ok=True)
    catalog_body = _render_catalog_markdown(catalog)
    catalog_path.write_text(catalog_body, encoding="utf-8")
    print(f"Wrote {catalog_path}")


if __name__ == "__main__":
    main()
