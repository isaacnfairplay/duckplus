"""Generate static DuckDB function namespace classes."""

from __future__ import annotations

from collections import defaultdict
import keyword
from pathlib import Path
from textwrap import indent

import duckdb

HEADER = """Auto-generated DuckDB function namespaces.

This file is generated by ``scripts/generate_function_namespaces.py``.
Do not edit by hand; regenerate to pull in new function definitions.
"""

SCHEMA_PRIORITY = {"main": 0, "duckdb": 1, "pg_catalog": 2}
RETURN_CATEGORY_DOCS = {
    "numeric": "numeric",
    "boolean": "boolean",
    "varchar": "string",
    "blob": "binary",
    "generic": "generic",
}
CATEGORY_TO_EXPRESSION = {
    "numeric": "NumericExpression",
    "boolean": "BooleanExpression",
    "varchar": "VarcharExpression",
    "blob": "BlobExpression",
    "generic": "TypedExpression",
}
STUB_VALID_TYPE_IGNORE = {"list"}


def _categorise_return_type(return_type: str | None) -> str:
    if return_type is None:
        return "generic"
    normalized = return_type.upper()
    if any(
        normalized.startswith(prefix)
        for prefix in (
            "TINYINT",
            "SMALLINT",
            "INTEGER",
            "BIGINT",
            "HUGEINT",
            "UTINYINT",
            "USMALLINT",
            "UINTEGER",
            "UBIGINT",
            "FLOAT",
            "DOUBLE",
            "DECIMAL",
            "REAL",
            "INTERVAL",
        )
    ):
        return "numeric"
    if normalized.startswith("BOOLEAN"):
        return "boolean"
    if any(
        normalized.startswith(prefix) for prefix in ("VARCHAR", "STRING", "TEXT", "JSON", "UUID")
    ):
        return "varchar"
    if normalized.startswith("BLOB"):
        return "blob"
    return "generic"


def _definition_sort_key(definition: tuple[str, str, str | None, tuple[str, ...], str | None]) -> tuple[int, int]:
    schema, _name, _rtype, parameters, _varargs = definition
    schema_priority = SCHEMA_PRIORITY.get(schema, 10)
    arity = len(parameters)
    return (schema_priority, arity)


def _load_definitions() -> dict[str, dict[str, dict[str, list[tuple[str, str, str | None, tuple[str, ...], str | None]]]]]:
    connection = duckdb.connect()
    try:
        rows = connection.execute(
            """
            SELECT schema_name, function_name, function_type, return_type,
                   parameter_types, varargs
              FROM duckdb_functions()
             WHERE function_type IN ('scalar', 'aggregate', 'window')
            """
        ).fetchall()
    finally:
        connection.close()

    index: dict[str, dict[str, dict[str, list[tuple[str, str, str | None, tuple[str, ...], str | None]]]]] = defaultdict(
        lambda: defaultdict(dict)
    )
    for schema_name, function_name, function_type, return_type, parameter_types, varargs in rows:
        category = _categorise_return_type(return_type)
        type_bucket = index[function_type]
        category_bucket = type_bucket.setdefault(category, defaultdict(list))
        parameter_tuple = tuple(parameter_types or ())
        category_bucket[function_name].append(
            (schema_name, function_name, return_type, parameter_tuple, varargs)
        )

    for type_bucket in index.values():
        for category_bucket in type_bucket.values():
            for overloads in category_bucket.values():
                overloads.sort(key=_definition_sort_key)

    return index


def _format_definition(
    schema: str,
    name: str,
    return_type: str | None,
    parameters: tuple[str, ...],
    varargs: str | None,
) -> str:
    return "\n".join(
        [
            "            DuckDBFunctionDefinition(",
            f"                schema_name={schema!r},",
            f"                function_name={name!r},",
            "                function_type=function_type,",
            f"                return_type={return_type!r},",
            f"                parameter_types={parameters!r},",
            f"                varargs={varargs!r},",
            "            ),",
        ]
    )


def _render_function_block(
    function_name: str,
    overloads: list[tuple[str, str, str | None, tuple[str, ...], str | None]],
    *,
    return_category: str,
) -> str:
    lines = [f"    {function_name} = _DuckDBFunctionCall(("]
    lines.extend(
        _format_definition(schema, name, return_type, parameters, varargs)
        for schema, name, return_type, parameters, varargs in overloads
    )
    lines.append("        ),")
    lines.append(f"        return_category={return_category!r},")
    lines.append("    )")
    return "\n".join(lines)


def _render_symbolic_mapping(
    overloads: dict[str, list[tuple[str, str, str | None, tuple[str, ...], str | None]]],
    *,
    return_category: str,
) -> str:
    if not overloads:
        return "    _SYMBOLIC_FUNCTIONS: ClassVar[dict[str, _DuckDBFunctionCall]] = {}"
    items = []
    for function_name in sorted(overloads):
        block_lines = ["        " + repr(function_name) + ": _DuckDBFunctionCall(("]
        block_lines.extend(
            indent(
                _format_definition(schema, name, return_type, parameters, varargs),
                "            ",
            )
            for schema, name, return_type, parameters, varargs in overloads[function_name]
        )
        block_lines.append("            ),")
        block_lines.append(f"            return_category={return_category!r},")
        block_lines.append("        ),")
        items.append("\n".join(block_lines))
    mapping = "\n".join(items)
    return "\n".join(
        [
            "    _SYMBOLIC_FUNCTIONS: ClassVar[dict[str, _DuckDBFunctionCall]] = {",
            mapping,
            "    }",
        ]
    )


def _render_namespace(
    *,
    function_type: str,
    category: str,
    identifiers: dict[str, list[tuple[str, str, str | None, tuple[str, ...], str | None]]],
    symbols: dict[str, list[tuple[str, str, str | None, tuple[str, ...], str | None]]],
) -> str:
    class_name = f"{function_type.title()}{category.title()}Functions"
    doc_category = RETURN_CATEGORY_DOCS.get(category, category)
    doc = f"DuckDB {function_type} functions returning {doc_category} results."
    lines: list[str] = [f"class {class_name}(_StaticFunctionNamespace):", f"    \"\"\"{doc}\"\"\""]
    lines.append("    __slots__ = ()")
    lines.append("    function_type: ClassVar[str] = " + repr(function_type))
    lines.append("    return_category: ClassVar[str] = " + repr(category))
    if identifiers:
        for function_name in sorted(identifiers):
            lines.append(
                _render_function_block(
                    function_name,
                    identifiers[function_name],
                    return_category=category,
                )
            )
        registry_lines = ["    _IDENTIFIER_FUNCTIONS: ClassVar[dict[str, _DuckDBFunctionCall]] = {"]
        for function_name in sorted(identifiers):
            registry_lines.append(f"        {function_name!r}: {function_name},")
        registry_lines.append("    }")
        lines.append("\n".join(registry_lines))
    else:
        lines.append("    _IDENTIFIER_FUNCTIONS: ClassVar[dict[str, _DuckDBFunctionCall]] = {}")
    lines.append(
        _render_symbolic_mapping(
            symbols,
            return_category=category,
        )
    )
    return "\n".join(lines)


def _render_stub_namespace(
    *,
    function_type: str,
    category: str,
    identifiers: dict[str, list[tuple[str, str, str | None, tuple[str, ...], str | None]]],
) -> str:
    class_name = f"{function_type.title()}{category.title()}Functions"
    expression = CATEGORY_TO_EXPRESSION[category]
    lines = [f"class {class_name}(_StaticFunctionNamespace[{expression}]):"]
    lines.append("    ...")
    if identifiers:
        for function_name in sorted(identifiers):
            annotation = f"    {function_name}: _DuckDBFunctionCall[{expression}]"
            if function_name in STUB_VALID_TYPE_IGNORE:
                annotation += "  # type: ignore[valid-type]"
            lines.append(annotation)
    return "\n".join(lines)


def _render_type_namespace(function_type: str, categories: dict[str, str]) -> str:
    class_name = f"{function_type.title()}FunctionNamespace"
    lines = [
        f"class {class_name}:",
        f"    \"\"\"DuckDB {function_type} function categories.\"\"\"",
        "    __slots__ = ()",
    ]
    for category_name, cls_name in categories.items():
        lines.append(
            f"    {category_name.title()}: {cls_name} = {cls_name}()  # noqa: N802"
        )
    lines.append("    def __dir__(self) -> list[str]:")
    lines.append(
        "        return sorted(name for name in self.__class__.__dict__ if not name.startswith('_'))"
    )
    return "\n".join(lines)


def _render_stub_type_namespace(function_type: str, categories: dict[str, str]) -> str:
    class_name = f"{function_type.title()}FunctionNamespace"
    lines = [f"class {class_name}:", "    ..."]
    for category_name, cls_name in categories.items():
        lines.append(f"    {category_name.title()}: {cls_name}")
    lines.append("    def __dir__(self) -> list[str]: ...")
    return "\n".join(lines)


def main() -> None:
    index = _load_definitions()
    for function_type in ("aggregate", "scalar", "window"):
        type_bucket = index.setdefault(function_type, {})
        for category in ("blob", "boolean", "generic", "numeric", "varchar"):
            type_bucket.setdefault(category, {})
    output_lines: list[str] = [
        "from __future__ import annotations",
        "",
        "from typing import ClassVar",
        "",
        "from .functions import DuckDBFunctionDefinition, _DuckDBFunctionCall, _StaticFunctionNamespace",
        "",
        "",
    ]
    stub_lines: list[str] = [
        "from __future__ import annotations",
        "",
        "from typing import ClassVar, Generic, Mapping, Tuple, TypeVar, Protocol",
        "",
        "from .expression import BlobExpression, BooleanExpression, GenericExpression, NumericExpression, TypedExpression, VarcharExpression",
        "",
        "class DuckDBFunctionDefinition: ...",
        "class DuckDBFunctionSignature: ...",
        "_ExprT = TypeVar('_ExprT', bound=TypedExpression, covariant=True)",
        "",
        "class _DuckDBFunctionCall(Protocol[_ExprT]):",
        "    signatures: Tuple[DuckDBFunctionSignature, ...]",
        "    function_type: str",
        "    def __call__(self, *operands: object) -> _ExprT: ...",
        "",
        "_NamespaceExprT = TypeVar('_NamespaceExprT', bound=TypedExpression)",
        "",
        "class _StaticFunctionNamespace(Generic[_NamespaceExprT]):",
        "    function_type: ClassVar[str]",
        "    return_category: ClassVar[str]",
        "    _IDENTIFIER_FUNCTIONS: ClassVar[Mapping[str, _DuckDBFunctionCall[_NamespaceExprT]]]",
        "    _SYMBOLIC_FUNCTIONS: ClassVar[Mapping[str, _DuckDBFunctionCall[_NamespaceExprT]]]",
        "    def __getitem__(self, name: str) -> _DuckDBFunctionCall[_NamespaceExprT]: ...",
        "    def get(",
        "        self,",
        "        name: str,",
        "        default: _DuckDBFunctionCall[_NamespaceExprT] | None = ...,",
        "    ) -> _DuckDBFunctionCall[_NamespaceExprT] | None: ...",
        "    def __contains__(self, name: object) -> bool: ...",
        "    @property",
        "    def symbols(self) -> Mapping[str, _DuckDBFunctionCall[_NamespaceExprT]]: ...",
        "    def __dir__(self) -> list[str]: ...",
        "",
    ]

    for function_type, categories in sorted(index.items()):
        for category, functions in sorted(categories.items()):
            identifiers: dict[str, list[tuple[str, str, str | None, tuple[str, ...], str | None]]] = {}
            symbols: dict[str, list[tuple[str, str, str | None, tuple[str, ...], str | None]]] = {}
            for name, overloads in functions.items():
                if name.isidentifier() and not keyword.iskeyword(name):
                    identifiers[name] = overloads
                else:
                    symbols[name] = overloads
            output_lines.append(
                _render_namespace(
                    function_type=function_type,
                    category=category,
                    identifiers=identifiers,
                    symbols=symbols,
                )
            )
            output_lines.append("")
            stub_lines.append(
                _render_stub_namespace(
                    function_type=function_type,
                    category=category,
                    identifiers=identifiers,
                )
            )
            stub_lines.append("")

        categories = {
            category: f"{function_type.title()}{category.title()}Functions"
            for category in sorted(categories)
        }
        output_lines.append(_render_type_namespace(function_type, categories))
        output_lines.append("")
        stub_lines.append(_render_stub_type_namespace(function_type, categories))
        stub_lines.append("")

    stub_lines.extend(
        [
            "class DuckDBFunctionNamespace:",
            "    ...",
            "    Scalar: ScalarFunctionNamespace",
            "    Aggregate: AggregateFunctionNamespace",
            "    Window: WindowFunctionNamespace",
            "    def __dir__(self) -> list[str]: ...",
            "",
            "SCALAR_FUNCTIONS: ScalarFunctionNamespace",
            "AGGREGATE_FUNCTIONS: AggregateFunctionNamespace",
            "WINDOW_FUNCTIONS: WindowFunctionNamespace",
            "",
            "__all__ = [",
            "    'DuckDBFunctionDefinition',",
            "    'DuckDBFunctionNamespace',",
            "    'DuckDBFunctionSignature',",
            "    'SCALAR_FUNCTIONS',",
            "    'AGGREGATE_FUNCTIONS',",
            "    'WINDOW_FUNCTIONS',",
            "]",
        ]
    )

    output_path = Path(__file__).resolve().parent.parent / "duckplus" / "typed" / "_generated_function_namespaces.py"
    output = "\n".join(output_lines).strip() + "\n"
    prologue = "# pylint: skip-file\n# mypy: ignore-errors\n\n" + f'"""{HEADER}\n"""\n\n'
    output_path.write_text(prologue + output, encoding="utf-8")
    print(f"Wrote {output_path}")

    stub_path = output_path.with_suffix(".pyi")
    stub_body = "\n".join(stub_lines).strip() + "\n"
    stub_prologue = f'"""{HEADER}\n"""\n\n'
    stub_path.write_text(stub_prologue + stub_body, encoding="utf-8")
    print(f"Wrote {stub_path}")


if __name__ == "__main__":
    main()
